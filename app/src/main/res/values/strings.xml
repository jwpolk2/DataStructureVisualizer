<resources>
    <string name="app_name">Data Structure Visualizer</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="dummy_button">Dummy Button</string>
    <string name="dummy_content">DUMMY\nCONTENT</string>
    <string name="save">Save</string>
    <string name="file_action">file_action</string>
    <string name="bst_overview_tree_body"><![CDATA[Trees are non-linear data structures which store data in nodes, allowing for efficient insert, update, and search inquiries. These structures follow a particular ordering property wherein given a node n all the left descendants will be < n < all right descendants.]]></string>
    <string name="bst_overview_bst_body">In binary search trees, each node can have a maximum of two children, giving binary search trees their name. Note that all trees are not binary trees, some can have more than two children such as a B+ tree. \n\nThe root node (node 1) is the first node of a tree, the parent of this node is null. \nThe root node of a tree is the parent of its left and right children (nodes 2 and 3). \nThe links that connect a parent to its children are called edges. \nThe nodes that have no children are leaf nodes (nodes 4, 5, and 6)</string>
    <string name="bst_overview_definitions_body_full">Full: every node has either zero or two children.\n</string>
    <string name="bst_overview_definitions_body_complete">Complete: every level in the tree is fully filled except for the last level, which should be filled from left to right.</string>
    <string name="bst_overview_definitions_body_perfect">Perfect: the tree is both full and complete, this tree will have 2^(n-1) nodes.</string>
    <string name="bst_code_insertion">The new node will be inserted in place of a null node in the current tree. Start at the root and check the relationship between the new node and the root node. If the new node is less than then root node go to the left child, otherwise go to the right child. Iteratively continue this process until a null node is reached. Insert the new node in place of the null node reached.</string>
    <string name="bst_code_deletion1">There are three cases you may encounter when deleting a node from a binary search tree.</string>
    <string name="bst_code_deletion2">Case 1: The node to be deleted is a leaf node</string>
    <string name="bst_code_deletion3">Simply remove the node from the tree.</string>
    <string name="bst_code_deletion4">Case 2: The node to be deleted has one child.</string>
    <string name="bst_code_deletion5">Replace the value of the node to be deleted with the value from the child node. \n\nDelete the child node.</string>
    <string name="bst_code_deletion6">Case 3: The node to be deleted has two children.</string>
    <string name="bst_code_deletion7">Find the in-order successor of the node to be delete, this will be the minimum value of the right subtree of the node to be deleted. \n\nReplace the node with this value. \n\nDelete the node of the in-order successor.</string>
    <string name="bst_code_traversals_overview">Traversals iterate over the tree in a certain order, performing an action on each node. The actions that are performed during traversals include adding nodes to a tree, performing an update, or, in the case of this visualizer, performing an animation.</string>
    <string name="bst_code_traversals_preOrder_overview">A pre-order traversal is a depth first traversal which performs an action on a node then explores its children from left to right. This is typically done recursively, though it can be done with a stack.</string>
    <string name="bst_code_traversals_preOrder_complexity">Time Complexity: O(n)</string>
    <string name="bst_code_traversals_preOrder_algorithm1">Algorithm:</string>
    <string name="bst_code_traversals_preOrder_algorithm2">Call the recursive traversal method with the Tree\'s root node.</string>
    <string name="bst_code_traversals_preOrder_algorithm3">Recursive traversal method:</string>
    <string name="bst_code_traversals_preOrder_algorithm4"><![CDATA[Return if the input node is null (base case). \n\nPrint the value of the node \n\nCall the recursive traversal method with the input node\'s left child \n\nCall the recursive traversal method with the input node\'s right child \n\nreturn]]></string>
    <string name="bst_code_traversals_postOrder_overview">A post-order traversal is a depth first traversal which explores a node’s children from left to right then performs an action on it. This is typically done recursively, though it can be done with a stack.</string>
    <string name="bst_code_traversals_postOrder_complexity">Time Complexity: O(n)</string>
    <string name="bst_code_traversals_postOrder_algorithm1">Algorithm:</string>
    <string name="bst_code_traversals_postOrder_algorithm2">Call the traversal method with the Tree\'s root.</string>
    <string name="bst_code_traversals_postOrder_algorithm3">Recursive traversal method:</string>
    <string name="bst_code_traversals_postOrder_algorithm4"><![CDATA[Return if the input node is null (base case). \n\nCall the recursive traversal method with the input node’s left child. \n\nCall the recursive traversal method with the input node’s right child. \n\nPrint the value of the input node. \n\nreturn]]></string>
    <string name="bst_code_traversals_inOrder_overview">"An in-order traversal is a depth first traversal which explores a node’s left child, performs an action on the node, then explores the node’s right child. This is typically done recursively, though it can be done with a stack. \n\nThis traversal will explore the tree in order since the binary trees discussed are structured such that the left subtree of a given node contains only nodes with smaller keys than said node and the right subtree of a given node contains only nodes with larger keys than said node. "</string>
    <string name="bst_code_traversals_inOrder_complexity">Time Complexity: O(n)</string>
    <string name="bst_code_traversals_inOrder_algorithm1">Algorithm:</string>
    <string name="bst_code_traversals_inOrder_algorithm2">Call the recursive traversal method with the Tree’s root.</string>
    <string name="bst_code_traversals_inOrder_algorithm3">Recursive traversal method:</string>
    <string name="bst_code_traversals_inOrder_algorithm4">"Return if the input node is null (base case). \n\nCall the recursive traversal method with the input node’s left child. \n\nPerform an action on the input node. \n\nCall the recursive traversal method with the input node’s right child. \n\nReturn. "</string>
    <string name="bst_code_traversals_breadthFirst_overview">"A breadth-first traversal explores all nodes on a layer before moving on to the next layer. It is trivial to modify the algorithm to move from right to left or vice-versa, so the ordering of insertions is not mentioned. It should be noticed that this traversal is conceptually similar to the breadth first path find of a graph. \n\nThe breadth-first traversal defined below requires that a queue of nodes to explore be maintained, though there are other algorithms which do not require a queue. "</string>
    <string name="bst_code_traversals_breadthFirst_complexity">Time Complexity: O(n)</string>
    <string name="bst_code_traversals_breadthFirst_algorithm1">Algorithm:</string>
    <string name="bst_code_traversals_breadthFirst_algorithm2">Add the Tree\'s root to the queue.</string>
    <string name="bst_code_traversals_breadthFirst_algorithm3">While the queue is non-empty:</string>
    <string name="bst_code_traversals_breadthFirst_algorithm4">Pop the node at the head of the queue. \n\nPerform an action on the popped node. \n\nAdd each child of the popped node to the queue.</string>
    <string name="bst_code_traversals_search_overview">A search will traverse the tree until the node containing the desired key is found. Searches use the ordering properties of trees to minimize execution time. For example, if searching for the lowest node in the tree, the search algorithm will naturally traverse only left subtrees since left children are always smaller than parents and right children. This algorithm is designed recursively, though it is typically done with a loop.</string>
    <string name="bst_code_traversals_search_complexity">Time Complexity: O(log(n)) when balanced, O(n) otherwise</string>
    <string name="bst_code_traversals_search_algorithm1">Algorithm:</string>
    <string name="bst_code_traversals_search_algorithm2">Call the recursive search method with the desired key and the root node.</string>
    <string name="bst_code_traversals_search_algorithm3">Recursive search method:</string>
    <string name="bst_code_traversals_search_algorithm4">If the input node is null, return and fail. \n\nElse if the input node contains the input key, perform some action and return. \n\nElse if the input key is less than the key of the input node, call the recursive search method with the left child of the current node. \n\nElse if the input key is greater than the key of the input node, call the recursive search method with the right child of the current node. \n\nReturn.</string>
    <string name="complexity_bst_overview">The time complexity of a binary search tree depends on its balance.</string>
    <string name="complexity_bst_balanced_overview">Let n be the number of nodes in the binary search tree sturcture.</string>
    <string name="complexity_bst_balanced_complexities">Insert: O(log(n))\nSearch: O(log(n))\nDelete: O(log(n))</string>
    <string name="complexity_bst_unbalanced_overview">Let n be the number of nodes in the binary search tree sturcture.</string>
    <string name="complexity_bst_unbalanced_complexities">Insert: O(n)\nSearch: O(n)\nDelete: O(n)</string>
    <string name="complexity_bst_traversals_overview">Because traversal such as in-order, pre-order, and post-order must visit every node in the tree they will have O(n) time complexity.</string>
    <string name="complexity_bst_traversals_complexities">Pre-Order: O(n) \nPost-Order: O(n) \nIn-Order: O(n) \nBreadth-First: O(n)</string>
    <string name="rbt_overview_rbt_body">The Red Black Tree is a type of self-balancing binary search tree. It does not adhere to as strict of balancing as AVL trees do. But the balancing is still enough to ensure log(n) insertions, deletions, and searches.</string>
    <string name="rbt_overview_rbt_property1">Red-black trees work by having an alternating pattern of red and black coloring following these properties:</string>
    <string name="rbt_overview_rbt_property2">1.\tEvery node is either red or black. \n\n2.\tThe root is black. \n\n3.\tThe leaves, which are all null nodes, are considered black. \n\n4.\tEvery red node must have two black children. A red node cannot have red children, but a black node can have black children. \n\n5.\tEvery path from a node to its leaves must have the same number of black children.</string>

</resources>