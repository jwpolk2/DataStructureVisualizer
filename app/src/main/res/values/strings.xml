<resources>
    <string name="app_name">Data Structure Visualizer</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="dummy_button">Dummy Button</string>
    <string name="dummy_content">DUMMY\nCONTENT</string>
    <string name="save">Save</string>
    <string name="file_action">file_action</string>
    <string name="bst_rbt_avl_overview_tree_body"><![CDATA[Trees are non-linear data structures which store data in nodes, allowing for efficient insert, update, and search inquiries. Some of these structures follow a particular ordering property wherein given a node n all the left descendants will be < n < all right descendants. Though not all trees will follow this property, the ones covered in this application will.]]></string>
    <string name="bst_overview_bst_body">In binary search trees, each node can have a maximum of two children, giving binary search trees their name. Note that all trees are not binary trees, some can have more than two children such as a B+ tree. \n\nThe root node (node 1) is the first node of a tree, the parent of this node is null. \nThe root node of a tree is the parent of its left and right children (nodes 2 and 3). \nThe links that connect a parent to its children are called edges. \nThe nodes that have no children are leaf nodes (nodes 4, 5, and 6)</string>
    <string name="bst_overview_definitions_body_full">Full: every node has either zero or two children.\n</string>
    <string name="bst_overview_definitions_body_complete">Complete: every level in the tree is fully filled except for the last level, which should be filled from left to right.</string>
    <string name="bst_overview_definitions_body_perfect">Perfect: the tree is both full and complete, this tree will have 2^(n-1) nodes.</string>
    <string name="bst_code_insertion">The new node will be inserted in place of a null node in the current tree. Start at the root and check the relationship between the new node and the root node. If the new node is less than then root node go to the left child, otherwise go to the right child. Iteratively continue this process until a null node is reached. Insert the new node in place of the null node reached.</string>
    <string name="bst_code_deletion1">There are three cases you may encounter when deleting a node from a binary search tree.</string>
    <string name="bst_code_deletion2">Case 1: The node to be deleted is a leaf node</string>
    <string name="bst_code_deletion3">Simply remove the node from the tree.</string>
    <string name="bst_code_deletion4">Case 2: The node to be deleted has one child.</string>
    <string name="bst_code_deletion5">Replace the value of the node to be deleted with the value from the child node. \n\nDelete the child node.</string>
    <string name="bst_code_deletion6">Case 3: The node to be deleted has two children.</string>
    <string name="bst_code_deletion7">Find the in-order successor of the node to be delete, this will be the minimum value of the right subtree of the node to be deleted. \n\nReplace the node with this value. \n\nDelete the node of the in-order successor.</string>
    <string name="code_traversals_overview">Traversals iterate over the tree in a certain order, performing an action on each node. The actions that are performed during traversals include adding nodes to a tree, performing an update, or, in the case of this visualizer, performing an animation.</string>
    <string name="code_traversals_preOrder_overview">A pre-order traversal is a depth first traversal which performs an action on a node then explores its children from left to right. This is typically done recursively, though it can be done with a stack.</string>
    <string name="code_traversals_preOrder_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_preOrder_algorithm1">Algorithm:</string>
    <string name="code_traversals_preOrder_algorithm2">Call the recursive traversal method with the Tree\'s root node.</string>
    <string name="code_traversals_preOrder_algorithm3">Recursive traversal method:</string>
    <string name="code_traversals_preOrder_algorithm4"><![CDATA[Return if the input node is null (base case). \n\nPrint the value of the node \n\nCall the recursive traversal method with the input node\'s left child \n\nCall the recursive traversal method with the input node\'s right child \n\nreturn]]></string>
    <string name="code_traversals_postOrder_overview">A post-order traversal is a depth first traversal which explores a node’s children from left to right then performs an action on it. This is typically done recursively, though it can be done with a stack.</string>
    <string name="code_traversals_postOrder_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_postOrder_algorithm1">Algorithm:</string>
    <string name="code_traversals_postOrder_algorithm2">Call the traversal method with the Tree\'s root.</string>
    <string name="code_traversals_postOrder_algorithm3">Recursive traversal method:</string>
    <string name="code_traversals_postOrder_algorithm4"><![CDATA[Return if the input node is null (base case). \n\nCall the recursive traversal method with the input node’s left child. \n\nCall the recursive traversal method with the input node’s right child. \n\nPrint the value of the input node. \n\nreturn]]></string>
    <string name="code_traversals_inOrder_overview">"An in-order traversal is a depth first traversal which explores a node’s left child, performs an action on the node, then explores the node’s right child. This is typically done recursively, though it can be done with a stack. \n\nThis traversal will explore the tree in order since the binary trees discussed are structured such that the left subtree of a given node contains only nodes with smaller keys than said node and the right subtree of a given node contains only nodes with larger keys than said node. "</string>
    <string name="code_traversals_inOrder_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_inOrder_algorithm1">Algorithm:</string>
    <string name="code_traversals_inOrder_algorithm2">Call the recursive traversal method with the Tree’s root.</string>
    <string name="code_traversals_inOrder_algorithm3">Recursive traversal method:</string>
    <string name="code_traversals_inOrder_algorithm4">"Return if the input node is null (base case). \n\nCall the recursive traversal method with the input node’s left child. \n\nPerform an action on the input node. \n\nCall the recursive traversal method with the input node’s right child. \n\nReturn. "</string>
    <string name="code_traversals_breadthFirst_overview">"A breadth-first traversal explores all nodes on a layer before moving on to the next layer. It is trivial to modify the algorithm to move from right to left or vice-versa, so the ordering of insertions is not mentioned. It should be noticed that this traversal is conceptually similar to the breadth first path find of a graph. \n\nThe breadth-first traversal defined below requires that a queue of nodes to explore be maintained, though there are other algorithms which do not require a queue. "</string>
    <string name="code_traversals_breadthFirst_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_breadthFirst_algorithm1">Algorithm:</string>
    <string name="code_traversals_breadthFirst_algorithm2">Add the Tree\'s root to the queue.</string>
    <string name="code_traversals_breadthFirst_algorithm3">While the queue is non-empty:</string>
    <string name="code_traversals_breadthFirst_algorithm4">Pop the node at the head of the queue. \n\nPerform an action on the popped node. \n\nAdd each child of the popped node to the queue.</string>
    <string name="code_traversals_search_overview">A search will traverse the tree until the node containing the desired key is found. Searches use the ordering properties of trees to minimize execution time. For example, if searching for the lowest node in the tree, the search algorithm will naturally traverse only left subtrees since left children are always smaller than parents and right children. This algorithm is designed recursively, though it is typically done with a loop.</string>
    <string name="code_traversals_search_complexity">Time Complexity: O(log(n)) when balanced, O(n) otherwise</string>
    <string name="algorithm">Algorithm:</string>
    <string name="code_traversals_search_algorithm2">Call the recursive search method with the desired key and the root node.</string>
    <string name="code_traversals_search_algorithm3">Recursive search method:</string>
    <string name="code_traversals_search_algorithm4">If the input node is null, return and fail. \n\nElse if the input node contains the input key, perform some action and return. \n\nElse if the input key is less than the key of the input node, call the recursive search method with the left child of the current node. \n\nElse if the input key is greater than the key of the input node, call the recursive search method with the right child of the current node. \n\nReturn.</string>
    <string name="complexity_bst_overview">The time complexity of a binary search tree depends on its balance.</string>
    <string name="complexity_bst_balanced_overview">Let n be the number of nodes in the binary search tree.</string>
    <string name="complexity_bstbalanced_rbt_avl_complexities">Insert: O(log(n))\nSearch: O(log(n))\nDelete: O(log(n))</string>
    <string name="complexity_bst_unbalanced_overview">Let n be the number of nodes in the binary search tree.</string>
    <string name="complexity_bst_unbalanced_complexities">Insert: O(n)\nSearch: O(n)\nDelete: O(n)</string>
    <string name="complexity_bst_traversals_overview">Because traversal such as in-order, pre-order, and post-order must visit every node in the tree they will have O(n) time complexity.</string>
    <string name="complexity_bst_traversals_complexities">Pre-Order: O(n) \nPost-Order: O(n) \nIn-Order: O(n) \nBreadth-First: O(n)</string>
    <string name="rbt_overview_rbt_body">The Red Black Tree is a type of self-balancing binary search tree. It does not adhere to as strict of balancing as AVL trees do. But the balancing is still enough to ensure log(n) insertions, deletions, and searches.</string>
    <string name="rbt_overview_rbt_property1">Red-black trees work by having an alternating pattern of red and black coloring following these properties:</string>
    <string name="rbt_overview_rbt_property2">1.\tEvery node is either red or black. \n\n2.\tThe root is black. \n\n3.\tThe leaves, which are all null nodes, are considered black. \n\n4.\tEvery red node must have two black children. A red node cannot have red children, but a black node can have black children. \n\n5.\tEvery path from a node to its leaves must have the same number of black children.</string>
    <string name="complexity_rbt_overview"> Since a red black tree maintains balance the complexities for insert, delete, and search are the same as those for a balanced binary search tree.</string>
    <string name="complexity_rbt_methods_overview"> Let n be the number of nodes in the red black tree.</string>
    <string name="rbt_code_insertion_overview">The insertion into a red-black tree starts off like in a binary search tree. However, to maintain the balance, after inserting the new node as a leaf a series of rotations and recolorings will need to be done.</string>
    <string name="rbt_code_insertion_algorithm1">New nodes are inserted at a leaf as would be done in a binary search tree. \n\nNew nodes are always colored red and are given two black NULL nodes \n\nAfter insertion red-black tree property violations are checked for.</string>
    <string name="rbt_code_insertion_algorithm2">Red violation: A red node has a red child (or the root is red) \n\nBlack violation: One path from a node to its leaves has more black nodes than another path.</string>
    <string name="rbt_code_insertion_algorithm3">During insertion, a red node is added so we know there are no black violations as the number of black nodes has not changed. \n\nIf the root node is red (first insertion into the tree) the fix is to simply change its color to black \n\nIf there is a red node with red children, this must be corrected to absolve the red violation.</string>
    <string name="rbt_code_insertion_algorithm4">Let N be the current node. P is N’s parent. G is N’s grandparent. U is N’s uncle and P’s sibling. \n\nN is red and P is red (since there is a red violation) \n\nG is black, since there was not a red violation prior to insertion \n\nU could be red or black and could be a left or right child.  \n\nP could be either a left or right child.</string>
    <string name="rbt_code_insertion_algorithm5">In the case where U is red:</string>
    <string name="rbt_code_insertion_algorithm6">It does not matter if U or P are left or right children. \n\nToggle the colors of P, U, and G: G and N should be red and P and U should be black.</string>
    <string name="rbt_code_insertion_algorithm7">Doing this does not change the number of black nodes in any path so no black violation needs to be checked for. \n\nA red violation may have been created with G and G’s parent; this will need to be checked for recursively wherein G will become the new N.  "</string>
    <string name="rbt_code_insertion_algorithm8">In the case where U is black:</string>
    <string name="rbt_code_insertion_algorithm9">Case N and P are both left children:</string>
    <string name="rbt_code_insertion_algorithm10">This is solved with a right rotation about node G. And changing the coloring of P to black and G to red.  \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_insertion_algorithm11">Case P is a left child, and N is a right child:</string>
    <string name="rbt_code_insertion_algorithm12">This case is resolved with a left rotation about node P and then a right rotation about node G. The coloring of N if changed to black and the coloring of G is changed to red.  \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_insertion_algorithm13">Case N and P are both right children:</string>
    <string name="rbt_code_insertion_algorithm14">This is solved with a left rotation about node G. And changing the coloring of P to black and G to red.  \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_insertion_algorithm15">Case N is a left child, and P is a right child:</string>
    <string name="rbt_code_insertion_algorithm16">This case is resolved with a right rotation about node P and then a left rotation about node G. The coloring of N if changed to black and the coloring of G is changed to red. \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_deletion_overview">When deleting a node from a red-black tree the red or black properties of the tree could be disturbed. If the node being deleted is black, then the black property will be violated. "</string>
    <string name="rbt_code_deletion_algorithm1">Consider a node which is to be deleted, call this nodeToBeDeleted. \n\nFirst save the color of the node into a variable originalColor. "</string>
    <string name="rbt_code_deletion_algorithm2">Case nodeToBeDeleted’s left child is null</string>
    <string name="rbt_code_deletion_algorithm3">Assign the value of the right child to a node X (even if it is null) \n\nReplace the node to be deleted with node X "</string>
    <string name="rbt_code_deletion_algorithm4">Case nodeToBeDeleted’s left child is not null and nodeToBeDeleted’s right child is null</string>
    <string name="rbt_code_deletion_algorithm5">Assign the value of the left child to the node X \n\nReplace the node to be deleted with node X</string>
    <string name="rbt_code_deletion_algorithm6">Case X’s left and right children are both not null</string>
    <string name="rbt_code_deletion_algorithm7">Find the minimum value in the right subtree of X (in-order successor), call this node Y \n\nSave the color of this node into the variable created earlier \n\nAssign the right child of Y to X \n\nIf Y is a direct child of nodeToBeDeleted, set the parent of X as Y, otherwise transplant Y with the right child of Y \n\nReplace nodeToBeDeleted with Y \n\nSet the color of Y with the color stored in the variable, if this color is Black the black property has been violated and will need to be fixed.</string>
    <string name="rbt_code_propertyfixes">Property Fixes after Deletion:</string>
    <string name="rbt_code_propertyfixes_black_title">Fix Black Property Violations:</string>
    <string name="rbt_code_propertyfixes_black1">These violations will occur when a black node is deleted. To fix this we assume that node X has an extra black descendant upon paths to its leaves.  \n\nThe extra black node can be removed when the following cases occur: reaching the root node, X points to a red-black node, or with rotations and recoloring.  \n\nRepeat the following steps until X is not the root of the tree an d the color of X is black.</string>
    <string name="rbt_code_propertyfixes_black2">If X is the left child of its parent, then assign the sibling of X to node W.</string>
    <string name="rbt_code_propertyfixes_black3">If W is red:</string>
    <string name="rbt_code_propertyfixes_black4">Set the color of W to be BLACK \n\nSet the color of X and W’s parent to be RED</string>
    <string name="rbt_code_propertyfixes_black5">Complete a left rotation about X and W’s parent. \n\nAfter this rotation X will have a new sibling. Assign W with the new right child of X’s parent.</string>
    <string name="rbt_code_propertyfixes_black6">If the color of both the right and left children of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black7">Set the color of W to RED \n\nAssign the parent of X to X.</string>
    <string name="rbt_code_propertyfixes_black8">Else if the color of the rightChild of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black9">Set the color of the leftChild of W as BLACK \n\nSet the color of W as RED</string>
    <string name="rbt_code_propertyfixes_black10">Complete a right-rotation about node W</string>
    <string name="rbt_code_propertyfixes_black11">After this rotation X will have a new sibling. Assign the rightChild of the parent of X to W.</string>
    <string name="rbt_code_propertyfixes_black12">Else:</string>
    <string name="rbt_code_propertyfixes_black13">Set the  color of W as the color of the parent of X. \n\nSet the color of the parent of parent of X as BLACK \n\nSet the color of the right child of W as BLACK</string>
    <string name="rbt_code_propertyfixes_black14">Complete a right-rotation about the parent of X</string>
    <string name="rbt_code_propertyfixes_black15">Set X as the root of the tree.</string>
    <string name="rbt_code_propertyfixes_black16">Else if X is the right child of its parent: then assign W to the sibling of X</string>
    <string name="rbt_code_propertyfixes_black17">If W is red</string>
    <string name="rbt_code_propertyfixes_black18">Set the color of W to be BLACK \n\nSet the color of X and W’s parent to be RED</string>
    <string name="rbt_code_propertyfixes_black19">Complete a right rotation about X and W’s parent.  \n\nAfter this rotation X will have a new sibling. \n\nAssign W with the new left child of X’s parent.</string>
    <string name="rbt_code_propertyfixes_black20">If the color of both the right and left children of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black21">Set the color of W to RED \n\nAssign the parent of X to X</string>
    <string name="rbt_code_propertyfixes_black22">Else if the color of the leftChild of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black23">Set the color of the rightChild of W as BLACK \n\nSet the color of W as RED</string>
    <string name="rbt_code_propertyfixes_black24">Complete a left-rotation about node W</string>
    <string name="rbt_code_propertyfixes_black25">After this rotation X will have a new sibling. \n\nAssign the leftChild of the parent of X to W.</string>
    <string name="rbt_code_propertyfixes_black26">Else:</string>
    <string name="rbt_code_propertyfixes_black27">Set the color of W as the color of the parent of X. \n\nSet the color of the parent of parent of X as BLACK •\tSet the color of the right child of W as BLACK</string>
    <string name="rbt_code_propertyfixes_black28">Complete a left-rotation about the parent of X</string>
    <string name="rbt_code_propertyfixes_black29">Set X as the root of the tree.</string>
    <string name="rbt_overview_avl_body">An AVL tree is a common way to implement tree balancing. Each node of the tree stores the height of the subtree created by that node. Using this information every node can be checked if it is height balanced. The nodes would not be height balanced if the difference between the height of its left and right subtrees is greater than one.</string>
    <string name="avl_code_insertion_overview">To start a node is inserted the same as in a binary search tree. This can result in the balance of some nodes changing to -2 or 2. Therefore each node must be checked and rotated recursively as needed. \n\nLet balance(n) = n.left.height - n.right.height </string>
    <string name="avl_code_insertion_algorithm1">Case balance is 2</string>
    <string name="avl_code_insertion_algorithm2">o\tIn this case the height of the left subtree is two larger than the height of the right subtree.  o\tIf the nodes are all hanging to the left this is called left left shape.  o\tIf the nodes are hanging to the right this is called left right shape.  o\tIf the tree is left right shape transform this to left left shape using a left rotation about the left child of the unbalanced node.  o\tOnce in left left shape use a right rotation about the unbalanced node.</string>
    <string name="avl_code_insertion_algorithm3">Case balance is -2</string>
    <string name="avl_code_insertion_algorithm4">o\tIn this case the height of the right subtree is two larger than the height of the left subtree.  o\tIf the nodes are all hanging to the left this is called right left shape.  o\tIf the nodes are hanging to the right this is called right right shape.  o\tIf the tree is right left shape transform this to right right shape using a right rotation about the right child of the unbalanced node.  o\tOnce in right right shape use a left rotation about the unbalanced node.</string>
    <string name="avl_code_insertion_algorithm5">•\tRecursively check the height of all nodes to ensure there are no more unbalanced nodes.</string>
    <string name="avl_code_deletion_overview">"Deleting a node in an AVL tree is similar to deletion in a binary search tree. However, this deletion may disturb the balance and rebalancing will need to be done. Consider deleting node X from the critical node A. A node is considered critical if their balance factor is "</string>
    <string name="avl_code_deletion_algorithm1">Case Node X is from the left subtree of A and the left child of A (B) has a balance factor of 0</string>
    <string name="avl_code_deletion_algorithm2">•\tThe node X is deleted from the left subtree of A and A has a balance of 2.  •\tThis is fixed by a right rotation about A, making A’s right child the new root of the subtree. •\tNode A will have a balance of 1 and node B will have a balance of -1</string>
    <string name="avl_code_deletion_algorithm3">Case Node X is from the left subtree of A and the left child of A (B) has a balance factor of 1</string>
    <string name="avl_code_deletion_algorithm4">•\tThe node X is deleted from the left subtree of A and A has a balance of 2.  •\tThis is fixed by a right rotation about A, making A’s right child the new root of the subtree. •\tNode A and B will have a balance of 0.</string>
    <string name="avl_code_deletion_algorithm5">Case Node X if from the right subtree of A and the left child of A has a balance factor of 0</string>
    <string name="avl_code_deletion_algorithm6">"•\tThe node X is deleted from the right subtree of A and node A has a balance of 2.  •\tThis is fixed by a left rotation about A, making A’s left child the new root of the subtree.  •\tNode A will have a balance of 1 and node B will have a balance of -1 "</string>
    <string name="avl_code_deletion_algorithm7">Case Node X if from the right subtree of A and the left child of A has a balance factor of 1</string>
    <string name="avl_code_deletion_algorithm8">"•\tThe node X is deleted from the right subtree of A and A has a balance of 2.  •\tThis is fixed by a left rotation about A, making A’s left child the new root of the subtree. •\tNode A and B will have a balance of 0. "</string>
    <string name="avl_code_deletion_algorithm9">Case Node X if from the right subtree of A and the left child of A has a balance factor of -1</string>
    <string name="avl_code_deletion_algorithm10">"•\tLet A be the critical node, B be A’s left child, C be B’s right child. •\tBalancing in this case involves a Left-Right rotation.  •\tThe first rotation is a left rotation about node B, making C the new left child of A. •\tThe second rotation is a right rotation about node A, making C the new root of the subtree with left child B and right child A.  "</string>
    <string name="avl_code_deletion_algorithm11">Case Node X if from the left subtree of A and the right child of A has a balance factor of -1</string>
    <string name="avl_code_deletion_algorithm12">"•\tLet A be the critical node, B be A’s right child, C be B’s left child. •\tBalancing in this case involves a Right-Left rotation.  •\tThe first rotation is a right rotation about node B, making C the new right child of A. •\tThe second rotation is a left rotation about node A, making C the new root of the subtree with left child A and right child B.  "</string>

</resources>