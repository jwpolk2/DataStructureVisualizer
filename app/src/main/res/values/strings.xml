<resources>
    <string name="app_name">Data Structure Visualizer</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="dummy_button">Dummy Button</string>
    <string name="dummy_content">DUMMY\nCONTENT</string>
    <string name="save">Save</string>
    <string name="file_action">file_action</string>
    <string name="bst_rbt_avl_overview_tree_body"><![CDATA[Trees are non-linear data structures which store data in nodes, allowing for efficient insert, update, and search inquiries. Some of these structures follow a particular ordering property wherein given a node n all the left descendants will be < n < all right descendants. Though not all trees will follow this property, the ones covered in this application will.]]></string>
    <string name="bst_overview_bst_body">In binary search trees, each node can have a maximum of two children, giving binary search trees their name. Note that all trees are not binary trees, some can have more than two children such as a B+ tree. \n\nThe root node (node 1) is the first node of a tree, the parent of this node is null. \nThe root node of a tree is the parent of its left and right children (nodes 2 and 3). \nThe links that connect a parent to its children are called edges. \nThe nodes that have no children are leaf nodes (nodes 4, 5, and 6)</string>
    <string name="bst_overview_definitions_body_full">Full: every node has either zero or two children.\n</string>
    <string name="bst_overview_definitions_body_complete">Complete: every level in the tree is fully filled except for the last level, which should be filled from left to right.</string>
    <string name="bst_overview_definitions_body_perfect">Perfect: the tree is both full and complete, this tree will have 2^(n-1) nodes.</string>
    <string name="bst_code_insertion">The new node will be inserted in place of a null node in the current tree. Start at the root and check the relationship between the new node and the root node. If the new node is less than then root node go to the left child, otherwise go to the right child. Iteratively continue this process until a null node is reached. Insert the new node in place of the null node reached.</string>
    <string name="bst_code_deletion1">There are three cases you may encounter when deleting a node from a binary search tree.</string>
    <string name="bst_code_deletion2">Case 1: The node to be deleted is a leaf node</string>
    <string name="bst_code_deletion3">Simply remove the node from the tree.</string>
    <string name="bst_code_deletion4">Case 2: The node to be deleted has one child.</string>
    <string name="bst_code_deletion5">Replace the value of the node to be deleted with the value from the child node. \n\nDelete the child node.</string>
    <string name="bst_code_deletion6">Case 3: The node to be deleted has two children.</string>
    <string name="bst_code_deletion7">Find the in-order successor of the node to be delete, this will be the minimum value of the right subtree of the node to be deleted. \n\nReplace the node with this value. \n\nDelete the node of the in-order successor.</string>
    <string name="code_traversals_overview">Traversals iterate over the tree in a certain order, performing an action on each node. The actions that are performed during traversals include adding nodes to a tree, performing an update, or, in the case of this visualizer, performing an animation.</string>
    <string name="code_traversals_preOrder_overview">A pre-order traversal is a depth first traversal which performs an action on a node then explores its children from left to right. This is typically done recursively, though it can be done with a stack.</string>
    <string name="code_traversals_preOrder_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_preOrder_algorithm1">Algorithm:</string>
    <string name="code_traversals_preOrder_algorithm2">Call the recursive traversal method with the Tree\'s root node.</string>
    <string name="code_traversals_preOrder_algorithm3">Recursive traversal method:</string>
    <string name="code_traversals_preOrder_algorithm4"><![CDATA[Return if the input node is null (base case). \n\nPrint the value of the node \n\nCall the recursive traversal method with the input node\'s left child \n\nCall the recursive traversal method with the input node\'s right child \n\nreturn]]></string>
    <string name="code_traversals_postOrder_overview">A post-order traversal is a depth first traversal which explores a node’s children from left to right then performs an action on it. This is typically done recursively, though it can be done with a stack.</string>
    <string name="code_traversals_postOrder_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_postOrder_algorithm1">Algorithm:</string>
    <string name="code_traversals_postOrder_algorithm2">Call the traversal method with the Tree\'s root.</string>
    <string name="code_traversals_postOrder_algorithm3">Recursive traversal method:</string>
    <string name="code_traversals_postOrder_algorithm4"><![CDATA[Return if the input node is null (base case). \n\nCall the recursive traversal method with the input node’s left child. \n\nCall the recursive traversal method with the input node’s right child. \n\nPrint the value of the input node. \n\nreturn]]></string>
    <string name="code_traversals_inOrder_overview">An in-order traversal is a depth first traversal which explores a node’s left child, performs an action on the node, then explores the node’s right child. This is typically done recursively, though it can be done with a stack. \n\nThis traversal will explore the tree in order since the binary trees discussed are structured such that the left subtree of a given node contains only nodes with smaller keys than said node and the right subtree of a given node contains only nodes with larger keys than said node. </string>
    <string name="code_traversals_inOrder_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_inOrder_algorithm1">Algorithm:</string>
    <string name="code_traversals_inOrder_algorithm2">Call the recursive traversal method with the Tree’s root.</string>
    <string name="code_traversals_inOrder_algorithm3">Recursive traversal method:</string>
    <string name="code_traversals_inOrder_algorithm4">Return if the input node is null (base case). \n\nCall the recursive traversal method with the input node’s left child. \n\nPerform an action on the input node. \n\nCall the recursive traversal method with the input node’s right child. \n\nReturn. </string>
    <string name="code_traversals_breadthFirst_overview">A breadth-first traversal explores all nodes on a layer before moving on to the next layer. It is trivial to modify the algorithm to move from right to left or vice-versa, so the ordering of insertions is not mentioned. It should be noticed that this traversal is conceptually similar to the breadth first path find of a graph. \n\nThe breadth-first traversal defined below requires that a queue of nodes to explore be maintained, though there are other algorithms which do not require a queue. </string>
    <string name="code_traversals_breadthFirst_complexity">Time Complexity: O(n)</string>
    <string name="code_traversals_breadthFirst_algorithm1">Algorithm:</string>
    <string name="code_traversals_breadthFirst_algorithm2">Add the Tree\'s root to the queue.</string>
    <string name="code_traversals_breadthFirst_algorithm3">While the queue is non-empty:</string>
    <string name="code_traversals_breadthFirst_algorithm4">Pop the node at the head of the queue. \n\nPerform an action on the popped node. \n\nAdd each child of the popped node to the queue.</string>
    <string name="code_traversals_search_overview">A search will traverse the tree until the node containing the desired key is found. Searches use the ordering properties of trees to minimize execution time. For example, if searching for the lowest node in the tree, the search algorithm will naturally traverse only left subtrees since left children are always smaller than parents and right children. This algorithm is designed recursively, though it is typically done with a loop.</string>
    <string name="code_traversals_search_complexity">Time Complexity: O(log(n)) when balanced, O(n) otherwise</string>
    <string name="algorithm">Algorithm:</string>
    <string name="code_traversals_search_algorithm2">Call the recursive search method with the desired key and the root node.</string>
    <string name="code_traversals_search_algorithm3">Recursive search method:</string>
    <string name="code_traversals_search_algorithm4">If the input node is null, return and fail. \n\nElse if the input node contains the input key, perform some action and return. \n\nElse if the input key is less than the key of the input node, call the recursive search method with the left child of the current node. \n\nElse if the input key is greater than the key of the input node, call the recursive search method with the right child of the current node. \n\nReturn.</string>
    <string name="complexity_bst_overview">The time complexity of a binary search tree depends on its balance.</string>
    <string name="complexity_bst_balanced_overview">Let n be the number of nodes in the binary search tree.</string>
    <string name="complexity_bstbalanced_rbt_avl_complexities">Insert: O(log(n))\nSearch: O(log(n))\nDelete: O(log(n))</string>
    <string name="complexity_bst_unbalanced_overview">Let n be the number of nodes in the binary search tree.</string>
    <string name="complexity_bst_unbalanced_complexities">Insert: O(n)\nSearch: O(n)\nDelete: O(n)</string>
    <string name="complexity_bst_traversals_overview">Because traversal such as in-order, pre-order, and post-order must visit every node in the tree they will have O(n) time complexity.</string>
    <string name="complexity_bst_traversals_complexities">Pre-Order: O(n) \nPost-Order: O(n) \nIn-Order: O(n) \nBreadth-First: O(n)</string>
    <string name="rbt_overview_rbt_body">The Red Black Tree is a type of self-balancing binary search tree. It does not adhere to as strict of balancing as AVL trees do. But the balancing is still enough to ensure log(n) insertions, deletions, and searches.</string>
    <string name="rbt_overview_rbt_property1">Red-black trees work by having an alternating pattern of red and black coloring following these properties:</string>
    <string name="rbt_overview_rbt_property2">1.\tEvery node is either red or black. \n\n2.\tThe root is black. \n\n3.\tThe leaves, which are all null nodes, are considered black. \n\n4.\tEvery red node must have two black children. A red node cannot have red children, but a black node can have black children. \n\n5.\tEvery path from a node to its leaves must have the same number of black children.</string>
    <string name="complexity_rbt_overview"> Since a red black tree maintains balance the complexities for insert, delete, and search are the same as those for a balanced binary search tree.</string>
    <string name="complexity_rbt_methods_overview"> Let n be the number of nodes in the red black tree.</string>
    <string name="rbt_code_insertion_overview">The insertion into a red-black tree starts off like in a binary search tree. However, to maintain the balance, after inserting the new node as a leaf a series of rotations and recolorings will need to be done.</string>
    <string name="rbt_code_insertion_algorithm1">New nodes are inserted at a leaf as would be done in a binary search tree. \n\nNew nodes are always colored red and are given two black NULL nodes \n\nAfter insertion red-black tree property violations are checked for.</string>
    <string name="rbt_code_insertion_algorithm2">Red violation: A red node has a red child (or the root is red) \n\nBlack violation: One path from a node to its leaves has more black nodes than another path.</string>
    <string name="rbt_code_insertion_algorithm3">During insertion, a red node is added so we know there are no black violations as the number of black nodes has not changed. \n\nIf the root node is red (first insertion into the tree) the fix is to simply change its color to black \n\nIf there is a red node with red children, this must be corrected to absolve the red violation.</string>
    <string name="rbt_code_insertion_algorithm4">Let N be the current node. P is N’s parent. G is N’s grandparent. U is N’s uncle and P’s sibling. \n\nN is red and P is red (since there is a red violation) \n\nG is black, since there was not a red violation prior to insertion \n\nU could be red or black and could be a left or right child.  \n\nP could be either a left or right child.</string>
    <string name="rbt_code_insertion_algorithm5">In the case where U is red:</string>
    <string name="rbt_code_insertion_algorithm6">It does not matter if U or P are left or right children. \n\nToggle the colors of P, U, and G: G and N should be red and P and U should be black.</string>
    <string name="rbt_code_insertion_algorithm7">Doing this does not change the number of black nodes in any path so no black violation needs to be checked for. \n\nA red violation may have been created with G and G’s parent; this will need to be checked for recursively wherein G will become the new N.  "</string>
    <string name="rbt_code_insertion_algorithm8">In the case where U is black:</string>
    <string name="rbt_code_insertion_algorithm9">Case N and P are both left children:</string>
    <string name="rbt_code_insertion_algorithm10">This is solved with a right rotation about node G. And changing the coloring of P to black and G to red.  \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_insertion_algorithm11">Case P is a left child, and N is a right child:</string>
    <string name="rbt_code_insertion_algorithm12">This case is resolved with a left rotation about node P and then a right rotation about node G. The coloring of N if changed to black and the coloring of G is changed to red.  \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_insertion_algorithm13">Case N and P are both right children:</string>
    <string name="rbt_code_insertion_algorithm14">This is solved with a left rotation about node G. And changing the coloring of P to black and G to red.  \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_insertion_algorithm15">Case N is a left child, and P is a right child:</string>
    <string name="rbt_code_insertion_algorithm16">This case is resolved with a right rotation about node P and then a left rotation about node G. The coloring of N if changed to black and the coloring of G is changed to red. \n\nThis maintains the node ordering and maintains an equal number of black nodes in the path down to each subtree. Because the resulting root of this subtree is black no further red violations need to be checked for.</string>
    <string name="rbt_code_deletion_overview">When deleting a node from a red-black tree the red or black properties of the tree could be disturbed. If the node being deleted is black, then the black property will be violated. "</string>
    <string name="rbt_code_deletion_algorithm1">Consider a node which is to be deleted, call this nodeToBeDeleted. \n\nFirst save the color of the node into a variable originalColor. </string>
    <string name="rbt_code_deletion_algorithm2">Case nodeToBeDeleted’s left child is null</string>
    <string name="rbt_code_deletion_algorithm3a" >Assign the value of the right child to a node X (even if it is null)</string>
    <string name="rbt_code_deletion_algorithm3b" >Replace the node to be deleted with node X</string>
    <string name="rbt_code_deletion_algorithm4">Case nodeToBeDeleted’s left child is not null and nodeToBeDeleted’s right child is null</string>
    <string name="rbt_code_deletion_algorithm5">Assign the value of the left child to the node X \n\nReplace the node to be deleted with node X</string>
    <string name="rbt_code_deletion_algorithm6">Case X’s left and right children are both not null</string>
    <string name="rbt_code_deletion_algorithm7">Find the minimum value in the right subtree of X (in-order successor), call this node Y \n\nSave the color of this node into the variable created earlier \n\nAssign the right child of Y to X \n\nIf Y is a direct child of nodeToBeDeleted, set the parent of X as Y, otherwise transplant Y with the right child of Y \n\nReplace nodeToBeDeleted with Y \n\nSet the color of Y with the color stored in the variable, if this color is Black the black property has been violated and will need to be fixed.</string>
    <string name="rbt_code_propertyfixes">Property Fixes after Deletion:</string>
    <string name="rbt_code_propertyfixes_black_title">Fix Black Property Violations:</string>
    <string name="rbt_code_propertyfixes_black1">These violations will occur when a black node is deleted. To fix this we assume that node X has an extra black descendant upon paths to its leaves.  \n\nThe extra black node can be removed when the following cases occur: reaching the root node, X points to a red-black node, or with rotations and recoloring.  \n\nRepeat the following steps until X is not the root of the tree an d the color of X is black.</string>
    <string name="rbt_code_propertyfixes_black2">If X is the left child of its parent, then assign the sibling of X to node W.</string>
    <string name="rbt_code_propertyfixes_black3">If W is red:</string>
    <string name="rbt_code_propertyfixes_black4">Set the color of W to be BLACK \n\nSet the color of X and W’s parent to be RED</string>
    <string name="rbt_code_propertyfixes_black5">Complete a left rotation about X and W’s parent. \n\nAfter this rotation X will have a new sibling. Assign W with the new right child of X’s parent.</string>
    <string name="rbt_code_propertyfixes_black6">If the color of both the right and left children of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black7">Set the color of W to RED \n\nAssign the parent of X to X.</string>
    <string name="rbt_code_propertyfixes_black8">Else if the color of the rightChild of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black9">Set the color of the leftChild of W as BLACK \n\nSet the color of W as RED</string>
    <string name="rbt_code_propertyfixes_black10">Complete a right-rotation about node W</string>
    <string name="rbt_code_propertyfixes_black11">After this rotation X will have a new sibling. Assign the rightChild of the parent of X to W.</string>
    <string name="rbt_code_propertyfixes_black12">Else:</string>
    <string name="rbt_code_propertyfixes_black13">Set the  color of W as the color of the parent of X. \n\nSet the color of the parent of parent of X as BLACK \n\nSet the color of the right child of W as BLACK</string>
    <string name="rbt_code_propertyfixes_black14">Complete a right-rotation about the parent of X</string>
    <string name="rbt_code_propertyfixes_black15">Set X as the root of the tree.</string>
    <string name="rbt_code_propertyfixes_black16">Else if X is the right child of its parent: then assign W to the sibling of X</string>
    <string name="rbt_code_propertyfixes_black17">If W is red</string>
    <string name="rbt_code_propertyfixes_black18">Set the color of W to be BLACK \n\nSet the color of X and W’s parent to be RED</string>
    <string name="rbt_code_propertyfixes_black19">Complete a right rotation about X and W’s parent.  \n\nAfter this rotation X will have a new sibling. \n\nAssign W with the new left child of X’s parent.</string>
    <string name="rbt_code_propertyfixes_black20">If the color of both the right and left children of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black21">Set the color of W to RED \n\nAssign the parent of X to X</string>
    <string name="rbt_code_propertyfixes_black22">Else if the color of the leftChild of W is BLACK:</string>
    <string name="rbt_code_propertyfixes_black23">Set the color of the rightChild of W as BLACK \n\nSet the color of W as RED</string>
    <string name="rbt_code_propertyfixes_black24">Complete a left-rotation about node W</string>
    <string name="rbt_code_propertyfixes_black25">After this rotation X will have a new sibling. \n\nAssign the leftChild of the parent of X to W.</string>
    <string name="rbt_code_propertyfixes_black26">Else:</string>
    <string name="rbt_code_propertyfixes_black27">Set the color of W as the color of the parent of X. \n\nSet the color of the parent of parent of X as BLACK \n\nSet the color of the right child of W as BLACK</string>
    <string name="rbt_code_propertyfixes_black28">Complete a left-rotation about the parent of X</string>
    <string name="rbt_code_propertyfixes_black29">Set X as the root of the tree.</string>
    <string name="rbt_overview_avl_body">An AVL tree is a common way to implement tree balancing. Each node of the tree stores the height of the subtree created by that node. Using this information every node can be checked if it is height balanced. The nodes would not be height balanced if the difference between the height of its left and right subtrees is greater than one.</string>
    <string name="avl_code_insertion_overview">To start a node is inserted the same as in a binary search tree. This can result in the balance of some nodes changing to -2 or 2. Therefore each node must be checked and rotated recursively as needed. \n\nLet balance(n) = n.left.height - n.right.height </string>
    <string name="avl_code_insertion_algorithm1">Case balance is 2</string>
    <string name="avl_code_insertion_algorithm2">In this case the height of the left subtree is two larger than the height of the right subtree.  \n\nIf the nodes are all hanging to the left this is called left left shape.  \n\nIf the nodes are hanging to the right this is called left right shape.  \n\nIf the tree is left right shape transform this to left left shape using a left rotation about the left child of the unbalanced node.  \n\nOnce in left left shape use a right rotation about the unbalanced node.</string>
    <string name="avl_code_insertion_algorithm3">Case balance is -2</string>
    <string name="avl_code_insertion_algorithm4">In this case the height of the right subtree is two larger than the height of the left subtree.  o\tIf the nodes are all hanging to the left this is called right left shape.  \n\nIf the nodes are hanging to the right this is called right right shape.  \n\nIf the tree is right left shape transform this to right right shape using a right rotation about the right child of the unbalanced node.  \n\nOnce in right right shape use a left rotation about the unbalanced node.</string>
    <string name="avl_code_insertion_algorithm5">\n\nRecursively check the height of all nodes to ensure there are no more unbalanced nodes.</string>
    <string name="avl_code_deletion_overview">Deleting a node in an AVL tree is similar to deletion in a binary search tree. However, this deletion may disturb the balance and rebalancing will need to be done. Consider deleting node X from the critical node A. A node is considered critical if their balance factor is</string>
    <string name="avl_code_deletion_algorithm1">Case Node X is from the left subtree of A and the left child of A (B) has a balance factor of 0</string>
    <string name="avl_code_deletion_algorithm2">\n\nThe node X is deleted from the left subtree of A and A has a balance of 2.  \n\nThis is fixed by a right rotation about A, making A’s right child the new root of the subtree. \n\nNode A will have a balance of 1 and node B will have a balance of -1</string>
    <string name="avl_code_deletion_algorithm3">Case Node X is from the left subtree of A and the left child of A (B) has a balance factor of 1</string>
    <string name="avl_code_deletion_algorithm4">\n\nThe node X is deleted from the left subtree of A and A has a balance of 2.  \n\nThis is fixed by a right rotation about A, making A’s right child the new root of the subtree. \n\nNode A and B will have a balance of 0.</string>
    <string name="avl_code_deletion_algorithm5">Case Node X if from the right subtree of A and the left child of A has a balance factor of 0</string>
    <string name="avl_code_deletion_algorithm6">\n\nThe node X is deleted from the right subtree of A and node A has a balance of 2.  \n\nThis is fixed by a left rotation about A, making A’s left child the new root of the subtree.  \n\nNode A will have a balance of 1 and node B will have a balance of -1</string>
    <string name="avl_code_deletion_algorithm7">Case Node X if from the right subtree of A and the left child of A has a balance factor of 1</string>
    <string name="avl_code_deletion_algorithm8">\n\nThe node X is deleted from the right subtree of A and A has a balance of 2.  \n\nThis is fixed by a left rotation about A, making A’s left child the new root of the subtree. \n\nNode A and B will have a balance of 0.</string>
    <string name="avl_code_deletion_algorithm9">Case Node X if from the right subtree of A and the left child of A has a balance factor of -1</string>
    <string name="avl_code_deletion_algorithm10">Let A be the critical node, B be A’s left child, C be B’s right child. \n\nBalancing in this case involves a Left-Right rotation.  \n\nThe first rotation is a left rotation about node B, making C the new left child of A. \n\nThe second rotation is a right rotation about node A, making C the new root of the subtree with left child B and right child A.  </string>
    <string name="avl_code_deletion_algorithm11">Case Node X if from the left subtree of A and the right child of A has a balance factor of -1</string>
    <string name="avl_code_deletion_algorithm12">Let A be the critical node, B be A’s right child, C be B’s left child. \n\nBalancing in this case involves a Right-Left rotation.  \n\nThe first rotation is a right rotation about node B, making C the new right child of A. \n\nThe second rotation is a left rotation about node A, making C the new root of the subtree with left child A and right child B.  </string>
    <string name="graph_overview_body1">Graphs are data structures which store nodes that are connected by edges. Said edges may be weighted, implying that there is an intrinsic cost associated with traversing the edge, or unweighted implying that each edge has no cost or equal cost. Further, graphs may be directed, implying that each edge can be traversed from its origin to its destination, or undirected, implying that traversal over an edge is wholly bidirectional. The unique strength of Graphs is that they are generic and can represent many diverse relationships. For example: </string>
    <string name="graph_overview_body2">Paths between bus stops could be represented by a weighted directed graph, with nodes being stations and edges representing routes. \n\nConnections in a social network could be represented by an unweighted undirected graph, with nodes being people and edges represents mutual friendships between two people. </string>
    <string name="graph_breadthfirst_overview">The breadth first pathfind is a simple search algorithm that produces a path between any inserted starting and destination nodes. This pathfind parses through all nodes adjacent to currently explored nodes until there are no more unexplored nodes left. \n\nTime Complexity: O(|E| + |V|) \n\nWhere E is the set of edges and V is the set of vertices. </string>
    <string name="graph_breadthfirst_algorithm1">The Breadth first described here requires that the user maintain a list of explored nodes and a queue of nodes to explore. The list of explored nodes is checked whenever a node is enqueued to prevent nodes from being explored more than once. The queue of nodes to explore is popped whenever the previous node has finished exploring. It contains all unexplored nodes which are adjacent to explored nodes, sorted (naturally) by time of insertion such that nodes which are inserted first are explored first. \n\nIt is also required that each node have a ‘previous’ field, which represents the previous node in the path. This is used to return the path after it is finished (note that deriving the path is not described here as it is fairly simple). </string>
    <string name="graph_breadthfirst_algorithm2">Set the previous value of the starting node to null. \n\nAdd the starting node to a queue. \n\nWhile the queue is non-empty: </string>
    <string name="graph_breadthfirst_algorithm3">Pop the node at the head of the queue. \n\nIf the popped Node has been explored, continue looping. \n\nAdd the popped node to the list of explored nodes. \n\nFor each edge that begins in the popped node: </string>
    <string name="graph_breadthfirst_algorithm4">If the popped node is the desired destination node, terminate pathfinding and return the path of the current node. \n\nOtherwise: </string>
    <string name="graph_breadthfirst_algorithm5">Assign the popped node as the previous node of the destination node. \n\nAdd the destination node to the queue. </string>
    <string name="graph_dijkstra_overview">The Dijkstra pathfind is a greedy best first search algorithm that produces a minimal cost path between any inserted starting and destination nodes. \n\nTime Complexity: O(|E| * log(|V|)) \n\nWhere E is the set of edges and V is the set of vertices. </string>
    <string name="graph_dijkstra_algorithm1">The Dijkstra pathfinding algorithm described here requires that the user maintain a list of explored nodes and apriority queue of nodes to explore. The list of explored nodes is checked whenever a node is enqueued to prevent nodes from being explored more than once. The priority queue of nodes to explore is popped whenever the previous node has finished exploring. It sorts nodes in terms of the cost of the path taken to reach them such that the node with the cheapest existing path is explored first. \n\nIt is also required that each node have a ‘previous’ field, which represents the previous node in the path. This is used to return the path after it is finished (note that deriving the path is not described here as it is fairly simple). </string>
    <string name="graph_dijkstra_algorithm2">Set the previous value of the starting node to null. \n\nAssign the cost of each node to infinity. \n\nAdd the starting node to a priority-queue with cost 0. \n\nWhile the priority-queue is non-empty: </string>
    <string name="graph_dijkstra_algorithm3">Pop the node at the head of the priority-queue. \n\nIf the popped node is the desired destination node, terminate pathfinding and return the path of the current node. \n\nIf the popped Node has been explored, continue looping. \n\nAdd the popped node to the list of explored nodes. \n\nFor each edge that begins in the popped node: </string>
    <string name="graph_dijkstra_algorithm4">Add the destination node of the edge to the priority-queue. The destination node will be assigned a cost equal to the cost of the current node plus the weight of the edge. \n\nIf the above cost is lower than the previous cost, assign the popped node as the previous node of the destination node. </string>
    <string name="graph_prim_overview">Prim’s algorithm is a greedy best first search that constructs a minimum spanning tree starting from an inputed Node. \n\nTime Complexity: O(|V|²) \n\nWhere V is the set of vertices. Note that the implementation provided is a simple one, and there are other implementations with lower time complexity. </string>
    <string name="graph_prim_algorithm1">The version of Prim’s algorithm described here requires that the user maintain a list of explored nodes and priority queue of edges to explore. The list of explored nodes is checked whenever a node is enqueued to prevent nodes from being explored more than once. The priority queue of edges to explore contains all edges adjacent to explored nodes and is sorted such that lower cost edges are explored first.</string>
    <string name="graph_prim_algorithm2">While the priority-queue is non-empty:</string>
    <string name="graph_prim_algorithm3">Pop the edge at the head of the priority-queue. \n\nIf the node at the destination of the popped edge has been explored, continue looping. \n\nAdd the destination node to the list of explored nodes. \n\nFor each edge that begins in the destination node: </string>
    <string name="graph_prim_algorithm4">Add the edge to the priority queue. Its cost will be assigned to its weight.</string>
    <string name="graph_kruskal_algorithm1">The version of Kruskal’s algorithm described here requires that the user maintain a list of trees and a priority queue of edges to explore. The list of trees tracks the minimum spanning trees. The priority queue of edges to explore contains all edges and is sorted such that lower cost edges are explored first.</string>
    <string name="graph_kruskal_algorithm2">Add all Nodes to their own trees. \n\nWhile the priority-queue is non-empty: </string>
    <string name="graph_kruskal_algorithm3">Pop the edge at the head of the priority-queue. \n\nIf the node at the destination of the edge is within the same tree as the node at the start of the edge, continue looping. \n\nAdd all nodes of the tree containing of the destination node to the tree containing the starting node. \n\nDelete the tree that contained the starting node. </string>
    <string name="graph_kruskal_overview">Kruskal’s algorithm finds the minimum spanning forest of a graph by combining the nodes connected by the cheapest edges into trees. \n\nTime Complexity: O(|E| * log |V|) \n\nWhere E is the set of edges and V is the set of vertices.</string>
    <string name="graph_traversals_overview">Where E is the set of edges and V is the set of vertices:</string>
    <string name="graph_traversals_complexities">"Breadth-First: O(|E| + |V|) \n\nDijkstra's Pathfind: O(|E| * log(|V|)) \n\nPrim's Algorithm: O(|V|²) \n\nKruskal's Algorithm: O(|E| * log |V|) "</string>
    <string name="complexity_avl_overview" > Since an AVL tree maintains balance the complexities for insert, delete, and search are the same as those for a balanced binary search tree.</string>
    <string name="complexity_avl_methods_overview" > Let n be the number of nodes in the AVL tree.</string>


</resources>